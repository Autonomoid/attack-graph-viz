<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Attack Path Graph Visualizer</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0f172a;
      --panel: #111827;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #38bdf8;
      --surface: rgba(255, 255, 255, 0.04);
      --shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(56, 189, 248, 0.15), transparent 40%),
        radial-gradient(circle at 80% 10%, rgba(14, 165, 233, 0.12), transparent 30%),
        linear-gradient(145deg, #0b1020 0%, #0b1329 45%, #0f172a 100%);
      color: var(--text);
      padding: 24px;
    }

    h1 {
      margin: 0 0 10px;
      font-weight: 800;
      letter-spacing: -0.03em;
    }

    p.lead {
      margin: 0 0 16px;
      color: var(--muted);
      max-width: 800px;
      line-height: 1.6;
    }

    .shell {
      max-width: 1200px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 18px;
      align-items: start;
    }

    .panel {
      background: var(--panel);
      border: 1px solid rgba(148, 163, 184, 0.12);
      border-radius: 16px;
      padding: 18px;
      box-shadow: var(--shadow);
    }

    form {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    label {
      font-weight: 600;
      letter-spacing: 0.01em;
    }

    input[type="number"] {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: var(--surface);
      color: var(--text);
      font-size: 15px;
      transition: border-color 120ms ease;
    }

    input[type="number"]:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.18);
    }

    button {
      padding: 12px 14px;
      border-radius: 12px;
      border: none;
      font-weight: 700;
      letter-spacing: 0.01em;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }

    button.primary {
      background: linear-gradient(120deg, #0ea5e9, #22d3ee);
      color: #0b1020;
      box-shadow: 0 15px 40px rgba(34, 211, 238, 0.35);
    }

    button.secondary {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
      border: 1px solid rgba(148, 163, 184, 0.3);
    }

    button:hover {
      transform: translateY(-1px);
    }

    .stat {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      padding: 12px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(148, 163, 184, 0.15);
    }

    .stat small {
      color: var(--muted);
    }

    .stat strong {
      font-size: 18px;
    }

    .legend {
      margin-top: 16px;
    }

    .legend-bar {
      width: 100%;
      height: 12px;
      border-radius: 999px;
      background: linear-gradient(90deg, #1d4ed8, #3b82f6, #eab308, #f97316, #ef4444);
      border: 1px solid rgba(148, 163, 184, 0.18);
    }

    .legend-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 4px;
      font-size: 12px;
      color: var(--muted);
    }

    .paths {
      display: grid;
      gap: 8px;
      margin-top: 12px;
      max-height: 240px;
      overflow: auto;
    }

    .path-card {
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(148, 163, 184, 0.12);
      color: var(--muted);
      font-size: 14px;
    }

    .canvas {
      position: relative;
      min-height: 700px;
    }

    svg {
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at 15% 25%, rgba(56, 189, 248, 0.07), transparent 35%),
        radial-gradient(circle at 80% 80%, rgba(34, 197, 94, 0.06), transparent 35%),
        rgba(255, 255, 255, 0.02);
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.14);
      box-shadow: var(--shadow);
    }

    .node circle {
      fill: #0ea5e9;
      stroke: rgba(255, 255, 255, 0.2);
      stroke-width: 1.5px;
    }

    .node text {
      fill: #e5e7eb;
      font-size: 12px;
      font-weight: 600;
      paint-order: stroke;
      stroke: rgba(15, 23, 42, 0.8);
      stroke-width: 3px;
      stroke-linejoin: round;
      pointer-events: none;
    }

    .link {
      stroke-linecap: round;
      mix-blend-mode: screen;
      opacity: 0.95;
    }

    @media (max-width: 960px) {
      .shell {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="shell">
    <div class="panel">
      <h1>Attack Path Explorer</h1>
      <p class="lead">Generate multiple random attack paths on a shared network graph. Edges with heavier and warmer strokes
        represent the segments reused by more paths.</p>

      <form id="controls">
        <div>
          <label for="pathCount">Number of attack paths</label>
          <input id="pathCount" type="number" min="1" max="80" value="8" />
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="primary" type="submit">Generate paths</button>
          <button class="secondary" type="button" id="resetGraph">Reset graph</button>
        </div>
      </form>

      <div class="stat" style="margin-top: 14px;">
        <div>
          <small>Paths plotted</small><br />
          <strong id="pathsPlotted">0</strong>
        </div>
        <div>
          <small>Peak edge reuse</small><br />
          <strong id="maxReuse">0x</strong>
        </div>
      </div>

      <div class="legend">
        <div class="legend-bar"></div>
        <div class="legend-labels">
          <span>Rarely used</span>
          <span>Most reused</span>
        </div>
      </div>

      <div class="paths" id="paths"></div>
    </div>

    <div class="canvas">
      <svg id="graph" viewBox="0 0 1200 800"></svg>
    </div>
  </div>

  <script>
    const width = 1200;
    const height = 800;
    const svg = d3.select('#graph');
    const linkLayer = svg.append('g');
    const nodeLayer = svg.append('g');
    let nodes = [];
    let links = [];
    let linkCounts = new Map();
    let generatedPaths = [];
    let simulation;

    function edgeKey(a, b) {
      return a < b ? `${a}-${b}` : `${b}-${a}`;
    }

    function makeBaseGraph(nodeCount = 15, extraLinks = 12) {
      nodes = Array.from({ length: nodeCount }, (_, i) => ({ id: i, label: `N${i + 1}` }));
      links = [];

      // Backbone to keep the graph connected
      for (let i = 0; i < nodeCount - 1; i++) {
        links.push({ source: i, target: i + 1 });
      }

      // Add extra random links
      for (let i = 0; i < extraLinks; i++) {
        let a = Math.floor(Math.random() * nodeCount);
        let b = Math.floor(Math.random() * nodeCount);
        if (a === b) {
          i--;
          continue;
        }
        const key = edgeKey(a, b);
        if (links.some((l) => edgeKey(l.source, l.target) === key)) {
          i--;
          continue;
        }
        links.push({ source: a, target: b });
      }

      linkCounts = new Map(links.map((l) => [edgeKey(l.source, l.target), 0]));
      generatedPaths = [];
      updateStats();
    }

    function randomPath() {
      const start = Math.floor(Math.random() * nodes.length);
      let current = start;
      const visited = new Set([current]);
      const path = [current];
      const desiredLength = 4 + Math.floor(Math.random() * 6); // 4-9 hops

      for (let step = 0; step < desiredLength; step++) {
        const neighbors = links
          .filter((l) => l.source === current || l.target === current)
          .map((l) => (l.source === current ? l.target : l.source))
          .filter((n) => !visited.has(n) || Math.random() < 0.25);

        if (neighbors.length === 0) break;
        current = neighbors[Math.floor(Math.random() * neighbors.length)];
        path.push(current);
        visited.add(current);
      }

      return path;
    }

    function generatePaths(count) {
      generatedPaths = [];
      linkCounts = new Map(links.map((l) => [edgeKey(l.source, l.target), 0]));

      for (let i = 0; i < count; i++) {
        const path = randomPath();
        generatedPaths.push(path);

        for (let j = 0; j < path.length - 1; j++) {
          const key = edgeKey(path[j], path[j + 1]);
          linkCounts.set(key, (linkCounts.get(key) || 0) + 1);
        }
      }

      updateGraphAppearance();
      renderPathList();
      updateStats();
    }

    function renderGraph() {
      simulation?.stop();

      simulation = d3
        .forceSimulation(nodes)
        .force('link', d3.forceLink(links).id((d) => d.id).distance(110).strength(0.9))
        .force('charge', d3.forceManyBody().strength(-380))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide(36))
        .on('tick', ticked);

      const linkSelection = linkLayer
        .selectAll('line')
        .data(links, (d) => edgeKey(d.source.id ?? d.source, d.target.id ?? d.target));

      linkSelection.exit().remove();

      const linkEnter = linkSelection
        .enter()
        .append('line')
        .attr('class', 'link')
        .attr('stroke', '#1e293b')
        .attr('stroke-width', 2);

      linkEnter.merge(linkSelection);

      const nodeSelection = nodeLayer.selectAll('g.node').data(nodes, (d) => d.id);
      nodeSelection.exit().remove();

      const nodeEnter = nodeSelection
        .enter()
        .append('g')
        .attr('class', 'node')
        .call(
          d3
            .drag()
            .on('start', (event, d) => {
              if (!event.active) simulation.alphaTarget(0.3).restart();
              d.fx = d.x;
              d.fy = d.y;
            })
            .on('drag', (event, d) => {
              d.fx = event.x;
              d.fy = event.y;
            })
            .on('end', (event, d) => {
              if (!event.active) simulation.alphaTarget(0);
              d.fx = null;
              d.fy = null;
            })
        );

      nodeEnter.append('circle').attr('r', 12);
      nodeEnter.append('text').attr('dy', 4).attr('x', 18).text((d) => d.label);

      nodeEnter.merge(nodeSelection);
      updateGraphAppearance();

      function ticked() {
        linkLayer
          .selectAll('line')
          .attr('x1', (d) => d.source.x)
          .attr('y1', (d) => d.source.y)
          .attr('x2', (d) => d.target.x)
          .attr('y2', (d) => d.target.y);

        nodeLayer.selectAll('g.node').attr('transform', (d) => `translate(${d.x},${d.y})`);
      }
    }

    function updateGraphAppearance() {
      const counts = Array.from(linkCounts.values());
      const maxCount = counts.length ? Math.max(...counts) : 0;
      const colorScale = d3.scaleSequential(d3.interpolateWarm).domain([0, Math.max(maxCount, 1)]);
      const widthScale = d3.scaleLinear().domain([0, Math.max(maxCount, 1)]).range([2, 12]);

      linkLayer.selectAll('line').each(function (d) {
        const key = edgeKey(d.source.id ?? d.source, d.target.id ?? d.target);
        const count = linkCounts.get(key) ?? 0;
        d3.select(this)
          .transition()
          .duration(300)
          .attr('stroke', colorScale(count))
          .attr('stroke-width', widthScale(count))
          .attr('opacity', 0.3 + (count / Math.max(maxCount || 1, 1)) * 0.7);
      });
    }

    function renderPathList() {
      const container = document.getElementById('paths');
      container.innerHTML = '';
      generatedPaths.forEach((path, idx) => {
        const card = document.createElement('div');
        card.className = 'path-card';
        card.textContent = `Path ${idx + 1}: ${path.map((p) => nodes[p].label).join(' â†’ ')}`;
        container.appendChild(card);
      });
    }

    function updateStats() {
      const maxCount = Math.max(0, ...Array.from(linkCounts.values()));
      document.getElementById('pathsPlotted').textContent = generatedPaths.length;
      document.getElementById('maxReuse').textContent = `${maxCount}x`;
    }

    document.getElementById('controls').addEventListener('submit', (event) => {
      event.preventDefault();
      const count = Math.max(1, Math.min(80, Number(document.getElementById('pathCount').value)));
      generatePaths(count);
    });

    document.getElementById('resetGraph').addEventListener('click', () => {
      makeBaseGraph();
      renderGraph();
      generatePaths(Number(document.getElementById('pathCount').value));
    });

    // Initial draw
    makeBaseGraph();
    renderGraph();
    generatePaths(Number(document.getElementById('pathCount').value));
  </script>
</body>
</html>
