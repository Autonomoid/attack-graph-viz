<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Attack Path Graph Visualizer</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0f172a;
      --panel: #111827;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #38bdf8;
      --surface: rgba(255, 255, 255, 0.04);
      --shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(56, 189, 248, 0.15), transparent 40%),
        radial-gradient(circle at 80% 10%, rgba(14, 165, 233, 0.12), transparent 30%),
        linear-gradient(145deg, #0b1020 0%, #0b1329 45%, #0f172a 100%);
      color: var(--text);
      padding: 24px;
    }

    h1 {
      margin: 0 0 10px;
      font-weight: 800;
      letter-spacing: -0.03em;
    }

    p.lead {
      margin: 0 0 16px;
      color: var(--muted);
      max-width: 800px;
      line-height: 1.6;
    }

    .shell {
      max-width: 1200px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 18px;
      align-items: start;
    }

    .panel {
      background: var(--panel);
      border: 1px solid rgba(148, 163, 184, 0.12);
      border-radius: 16px;
      padding: 18px;
      box-shadow: var(--shadow);
    }

    form {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    label {
      font-weight: 600;
      letter-spacing: 0.01em;
    }

    input[type="number"] {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: var(--surface);
      color: var(--text);
      font-size: 15px;
      transition: border-color 120ms ease;
    }

    input[type="number"]:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.18);
    }

    button {
      padding: 12px 14px;
      border-radius: 12px;
      border: none;
      font-weight: 700;
      letter-spacing: 0.01em;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }

    button.primary {
      background: linear-gradient(120deg, #0ea5e9, #22d3ee);
      color: #0b1020;
      box-shadow: 0 15px 40px rgba(34, 211, 238, 0.35);
    }

    button.secondary {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
      border: 1px solid rgba(148, 163, 184, 0.3);
    }

    button:hover {
      transform: translateY(-1px);
    }

    .stat {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      padding: 12px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(148, 163, 184, 0.15);
    }

    .stat small {
      color: var(--muted);
    }

    .stat strong {
      font-size: 18px;
    }

    .legend {
      margin-top: 16px;
    }

    .legend-bar {
      width: 100%;
      height: 12px;
      border-radius: 999px;
      background: linear-gradient(90deg, #1d4ed8, #3b82f6, #eab308, #f97316, #ef4444);
      border: 1px solid rgba(148, 163, 184, 0.18);
    }

    .legend-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 4px;
      font-size: 12px;
      color: var(--muted);
    }

    .paths {
      display: grid;
      gap: 8px;
      margin-top: 12px;
      max-height: 240px;
      overflow: auto;
    }

    .path-card {
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(148, 163, 184, 0.12);
      color: var(--muted);
      font-size: 14px;
    }

    .canvas {
      position: relative;
      min-height: 700px;
    }

    svg {
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at 15% 25%, rgba(56, 189, 248, 0.07), transparent 35%),
        radial-gradient(circle at 80% 80%, rgba(34, 197, 94, 0.06), transparent 35%),
        rgba(255, 255, 255, 0.02);
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.14);
      box-shadow: var(--shadow);
    }

    .node circle {
      fill: #0ea5e9;
      stroke: rgba(255, 255, 255, 0.2);
      stroke-width: 1.5px;
    }

    .node text {
      fill: #e5e7eb;
      font-size: 12px;
      font-weight: 600;
      paint-order: stroke;
      stroke: rgba(15, 23, 42, 0.8);
      stroke-width: 3px;
      stroke-linejoin: round;
      pointer-events: none;
    }

    .link {
      stroke-linecap: round;
      mix-blend-mode: screen;
      opacity: 0.95;
    }

    @media (max-width: 960px) {
      .shell {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="shell">
    <div class="panel">
      <h1>Attack Path Explorer</h1>
      <p class="lead">Generate multiple random attack paths on a shared network graph. Edges with heavier and warmer strokes
        represent the segments reused by more paths.</p>

      <form id="controls">
        <div>
          <label for="pathCount">Number of attack paths</label>
          <input id="pathCount" type="number" min="1" max="80" value="8" />
        </div>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
          <div>
            <label for="nodeCount">Node count</label>
            <input id="nodeCount" type="number" min="6" max="40" value="15" />
          </div>
          <div>
            <label for="extraLinks">Extra cross-links</label>
            <input id="extraLinks" type="number" min="4" max="60" value="12" />
          </div>
        </div>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
          <div>
            <label for="minHops">Min hops per path</label>
            <input id="minHops" type="number" min="2" max="18" value="4" />
          </div>
          <div>
            <label for="maxHops">Max hops per path</label>
            <input id="maxHops" type="number" min="3" max="24" value="9" />
          </div>
        </div>
        <div>
          <label for="revisitChance">Chance to revisit a seen node (0-1)</label>
          <input id="revisitChance" type="number" min="0" max="1" step="0.05" value="0.25" />
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="primary" type="submit">Generate paths</button>
          <button class="secondary" type="button" id="resetGraph">Reset graph</button>
        </div>
      </form>

      <div class="stat" style="margin-top: 14px;">
        <div>
          <small>Paths plotted</small><br />
          <strong id="pathsPlotted">0</strong>
        </div>
        <div>
          <small>Peak edge reuse</small><br />
          <strong id="maxReuse">0x</strong>
        </div>
      </div>

      <div class="legend">
        <div class="legend-bar"></div>
        <div class="legend-labels">
          <span>Rarely used</span>
          <span>Most reused</span>
        </div>
      </div>

      <div class="paths" id="paths"></div>
    </div>

    <div class="canvas">
      <svg id="graph" viewBox="0 0 1200 800"></svg>
    </div>
  </div>

  <script>
    const width = 1200;
    const height = 800;
    const svg = d3.select('#graph');
    const linkLayer = svg.append('g');
    const nodeLayer = svg.append('g');
    let nodes = [];
    let links = [];
    let linkCounts = new Map();
    let generatedPaths = [];
    let simulation;
    let currentGraphConfig = { nodeCount: 0, extraLinks: 0 };

    function nodeId(node) {
      return typeof node === 'object' ? node.id ?? node.index ?? node : node;
    }

    function edgeKey(a, b) {
      const aId = nodeId(a);
      const bId = nodeId(b);
      return aId < bId ? `${aId}-${bId}` : `${bId}-${aId}`;
    }

    function makeBaseGraph(nodeCount = 15, extraLinks = 12) {
      nodes = Array.from({ length: nodeCount }, (_, i) => ({ id: i, label: `N${i + 1}` }));
      links = [];
      currentGraphConfig = { nodeCount, extraLinks };

      // Backbone to keep the graph connected
      for (let i = 0; i < nodeCount - 1; i++) {
        links.push({ source: i, target: i + 1 });
      }

      // Add extra random links
      for (let i = 0; i < extraLinks; i++) {
        let a = Math.floor(Math.random() * nodeCount);
        let b = Math.floor(Math.random() * nodeCount);
        if (a === b) {
          i--;
          continue;
        }
        const key = edgeKey(a, b);
        if (links.some((l) => edgeKey(l.source, l.target) === key)) {
          i--;
          continue;
        }
        links.push({ source: a, target: b });
      }

      linkCounts = new Map(links.map((l) => [edgeKey(l.source, l.target), 0]));
      generatedPaths = [];
      updateStats();
    }

    function randomPath({ minHops, maxHops, revisitChance }) {
      const start = Math.floor(Math.random() * nodes.length);
      let current = start;
      const visited = new Set([current]);
      const path = [current];
      const desiredLength = Math.max(minHops, Math.min(maxHops, minHops + Math.floor(Math.random() * (maxHops - minHops + 1))));

      for (let step = 0; step < desiredLength; step++) {
        const neighbors = links
          .filter((l) => nodeId(l.source) === current || nodeId(l.target) === current)
          .map((l) => (nodeId(l.source) === current ? nodeId(l.target) : nodeId(l.source)))
          .filter((n) => !visited.has(n) || Math.random() < revisitChance);

        if (neighbors.length === 0) break;
        current = neighbors[Math.floor(Math.random() * neighbors.length)];
        path.push(current);
        visited.add(current);
      }

      return path;
    }

    function generatePaths(count) {
      const config = getConfig();
      generatedPaths = [];
      linkCounts = new Map(links.map((l) => [edgeKey(l.source, l.target), 0]));

      for (let i = 0; i < count; i++) {
        const path = randomPath(config);
        generatedPaths.push(path);

        for (let j = 0; j < path.length - 1; j++) {
          const key = edgeKey(path[j], path[j + 1]);
          linkCounts.set(key, (linkCounts.get(key) || 0) + 1);
        }
      }

      updateGraphAppearance();
      renderPathList();
      updateStats();
    }

    function getConfig() {
      const nodeCount = clamp(Number(document.getElementById('nodeCount').value), 6, 40);
      const extraLinks = clamp(Number(document.getElementById('extraLinks').value), 4, 60);
      const minHops = clamp(Number(document.getElementById('minHops').value), 2, 18);
      const maxHops = clamp(Number(document.getElementById('maxHops').value), minHops + 1, 24);
      const revisitChance = clamp(Number(document.getElementById('revisitChance').value), 0, 1);

      document.getElementById('nodeCount').value = nodeCount;
      document.getElementById('extraLinks').value = extraLinks;
      document.getElementById('minHops').value = minHops;
      document.getElementById('maxHops').value = maxHops;
      document.getElementById('revisitChance').value = revisitChance.toFixed(2);

      return { nodeCount, extraLinks, minHops, maxHops, revisitChance };
    }

    function clamp(value, min, max) {
      if (Number.isNaN(value)) return min;
      return Math.max(min, Math.min(max, value));
    }

    function renderGraph() {
      simulation?.stop();

      simulation = d3
        .forceSimulation(nodes)
        .force('link', d3.forceLink(links).id((d) => d.id).distance(110).strength(0.9))
        .force('charge', d3.forceManyBody().strength(-380))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide(36))
        .on('tick', ticked);

      const linkSelection = linkLayer
        .selectAll('line')
        .data(links, (d) => edgeKey(d.source.id ?? d.source, d.target.id ?? d.target));

      linkSelection.exit().remove();

      const linkEnter = linkSelection
        .enter()
        .append('line')
        .attr('class', 'link')
        .attr('stroke', '#1e293b')
        .attr('stroke-width', 2);

      linkEnter.merge(linkSelection);

      const nodeSelection = nodeLayer.selectAll('g.node').data(nodes, (d) => d.id);
      nodeSelection.exit().remove();

      const nodeEnter = nodeSelection
        .enter()
        .append('g')
        .attr('class', 'node')
        .call(
          d3
            .drag()
            .on('start', (event, d) => {
              if (!event.active) simulation.alphaTarget(0.3).restart();
              d.fx = d.x;
              d.fy = d.y;
            })
            .on('drag', (event, d) => {
              d.fx = event.x;
              d.fy = event.y;
            })
            .on('end', (event, d) => {
              if (!event.active) simulation.alphaTarget(0);
              d.fx = null;
              d.fy = null;
            })
        );

      nodeEnter.append('circle').attr('r', 12);
      nodeEnter.append('text').attr('dy', 4).attr('x', 18).text((d) => d.label);

      nodeEnter.merge(nodeSelection);
      updateGraphAppearance();

      function ticked() {
        linkLayer
          .selectAll('line')
          .attr('x1', (d) => d.source.x)
          .attr('y1', (d) => d.source.y)
          .attr('x2', (d) => d.target.x)
          .attr('y2', (d) => d.target.y);

        nodeLayer.selectAll('g.node').attr('transform', (d) => `translate(${d.x},${d.y})`);
      }
    }

    function updateGraphAppearance() {
      const counts = Array.from(linkCounts.values());
      const usedMax = Math.max(0, ...counts.filter((c) => c > 0));
      const upper = usedMax <= 1 ? 2 : usedMax; // avoid zero-width domains so the heatmap always renders
      const colorScale = d3.scaleSequential(d3.interpolateTurbo).domain([1, upper]);
      const widthScale = d3.scaleLinear().domain([1, upper]).range([3, 14]);

      linkLayer.selectAll('line').each(function (d) {
        const key = edgeKey(d.source.id ?? d.source, d.target.id ?? d.target);
        const count = linkCounts.get(key) ?? 0;
        const selection = d3
          .select(this)
          .transition()
          .duration(300);

        if (count > 0) {
          selection
            .attr('stroke', colorScale(count))
            .attr('stroke-width', widthScale(count))
            .attr('opacity', 0.35 + (count / upper) * 0.65);
        } else {
          selection.attr('stroke', '#1e293b').attr('stroke-width', 2).attr('opacity', 0.22);
        }
      });
    }

    function renderPathList() {
      const container = document.getElementById('paths');
      container.innerHTML = '';
      generatedPaths.forEach((path, idx) => {
        const card = document.createElement('div');
        card.className = 'path-card';
        card.textContent = `Path ${idx + 1}: ${path.map((p) => nodes[p].label).join(' â†’ ')}`;
        container.appendChild(card);
      });
    }

    function updateStats() {
      const maxCount = Math.max(0, ...Array.from(linkCounts.values()));
      document.getElementById('pathsPlotted').textContent = generatedPaths.length;
      document.getElementById('maxReuse').textContent = `${maxCount}x`;
    }

    document.getElementById('controls').addEventListener('submit', (event) => {
      event.preventDefault();
      const count = Math.max(1, Math.min(80, Number(document.getElementById('pathCount').value)));
      const { nodeCount, extraLinks } = getConfig();
      const graphChanged =
        nodeCount !== currentGraphConfig.nodeCount || extraLinks !== currentGraphConfig.extraLinks;

      if (graphChanged) {
        makeBaseGraph(nodeCount, extraLinks);
        renderGraph();
      }

      generatePaths(count);
    });

    document.getElementById('resetGraph').addEventListener('click', () => {
      const { nodeCount, extraLinks } = getConfig();
      makeBaseGraph(nodeCount, extraLinks);
      renderGraph();
      generatePaths(Number(document.getElementById('pathCount').value));
    });

    // Initial draw
    const initialConfig = getConfig();
    makeBaseGraph(initialConfig.nodeCount, initialConfig.extraLinks);
    renderGraph();
    generatePaths(Number(document.getElementById('pathCount').value));
  </script>
</body>
</html>
